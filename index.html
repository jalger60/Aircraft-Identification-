<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aircraft Identifier</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/jimp/browser/lib/jimp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>

    <header class="site-header">
    <div class="nav-container">
        <!-- ACCESSIBILITY Best Practice: Wrapped the logo in a link to the homepage. -->
        <a href="index.html" class="logo">AeroVision</a>
        
        <!-- ACCESSIBILITY Best Practice: Added an aria-label to describe the purpose of the navigation. -->
        <nav class="main-nav" aria-label="Main navigation">
            <ul>
                <!-- Boeing Dropdown Menu -->
                <li class="dropdown">
                    <!-- 
                        ACCESSIBILITY CHANGES:
                        1. aria-haspopup="true":  Tells screen readers that this link opens a menu.
                        2. aria-expanded="false": Informs the user that the menu is currently closed.
                        3. aria-controls="boeing-submenu": Programmatically links this button to the submenu it controls.
                    -->
                    <a href="#" aria-haspopup="true" aria-expanded="false" aria-controls="boeing-submenu">Boeing <span class="arrow">&#9662;</span></a>
                    
                    <!-- ACCESSIBILITY: Added a unique 'id' to be referenced by the 'aria-controls' attribute above. -->
                    <ul class="submenu" id="boeing-submenu">
                        <li><a href="boeing777.html">Boeing 777</a></li>
                        <li><a href="#">Boeing 787</a></li>
                    </ul>
                </li>

                <!-- Airbus Dropdown Menu -->
                <li class="dropdown">
                    <!-- ACCESSIBILITY: Same ARIA attributes applied for the Airbus menu. -->
                    <a href="#" aria-haspopup="true" aria-expanded="false" aria-controls="airbus-submenu">Airbus <span class="arrow">&#9662;</span></a>
                    
                    <!-- ACCESSIBILITY: Added a unique 'id' for the Airbus submenu. -->
                    <ul class="submenu" id="airbus-submenu">
                        <li><a href="Airbus A380.html">Airbus A380</a></li>
                        <li><a href="#">Airbus A320</a></li>
                    </ul>
                </li>
            </ul>
            </nav>
        </div>
    </header>

    <main>
        <div class="main-container">
            <section class="hero-section">
                <div class="hero-text">
                    <h1>Aircraft Identifier</h1>
                    <p>
                        Use cutting-edge machine learning to identify aircraft instantly.
                        This tool runs entirely in your browserâ€”just upload an image to begin your discovery.
                    </p>
                </div>
                <div class="hero-image">
                </div>
            </section>

            <section class="tool-section">
                <div class="tool-content">
                    <h2>Upload Your Image</h2>
                    <p class="instructions">Select a photo of an aircraft. Our in-browser model will analyze it and provide the top predictions.</p>
                    <input type="file" id="file-upload" onchange="inputChanged(event)" style="display: none;"/>
                    <label for="file-upload" class="upload-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-upload"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                        Choose File
                    </label>
                </div>
                <div class="prediction-area">
                    <h3>Prediction Results</h3>
                    <section class="status-section">
                      <p><strong>Status:</strong> <span id="status-output">Loading model...</span></p>
                    </section>
                    <section class="output-section">
                      <h2>Model Output</h2>
                      <div id="model-output" class="placeholder-text">Predictions will appear here...</div>
                    </section>
                </div>
            </section>
        </div>
    </main>
<script>
    // Added a new status for when the model is ready
    const statusDict = ["Waiting for file", "Loading file", "Performing inference", "Inference complete", "Model loaded, ready for files."];
    const modelClasses = ['Airbus A330', 'Airbus A350', 'Airbus A380', 'Boeing 777', 'Boeing 737 Max' ];
    const statusOutput = document.getElementById("status-output");
    
    // --- CHANGE 1: Add a global variable to manage the timer ---
    let clearResultsTimer = null;

    // --- OPTIMIZATION: Load the model once when the page starts ---
    let inferenceSession;
    async function initializeModel() {
      try {
        statusOutput.textContent = "Loading model...";
        // This line runs only ONCE, loading the model into memory
        inferenceSession = await ort.InferenceSession.create('aircraft_model.onnx');
        // Update the status to show the app is ready
        statusOutput.textContent = statusDict[4];
      } catch (e) {
        statusOutput.textContent = `Error loading model: ${e.message}`;
      }
    }
    // Run the model loader
    initializeModel();

    async function getImageTensorFromPath(path, dims = [1, 3, 224, 224]) {
      const image = await loadImagefromPath(path, dims[2], dims[3]);
      return imageDataToTensor(image, dims);
    }

    async function loadImagefromPath(path, width = 224, height = 224) {
            var imageData = await Jimp.read(path).then((imageBuffer) => {
                return imageBuffer.cover(width, height);
            });
            return imageData;
        }

    function imageDataToTensor(image, dims) {
          const imageBufferData = image.bitmap.data;
          const [batch, channels, height, width] = dims;
          const float32Data = new Float32Array(channels * height * width);
          for (let i = 0, px = 0; i < imageBufferData.length; i += 4, px++) {
            const r = (imageBufferData[i] / 255 - 0.5) / 0.5;
            const g = (imageBufferData[i + 1] / 255 - 0.5) / 0.5;
            const b = (imageBufferData[i + 2] / 255 - 0.5) / 0.5;
            float32Data[0 * width * height + px] = r;
            float32Data[1 * width * height + px] = g;
            float32Data[2 * width * height + px] = b;
          }
          const inputTensor = new ort.Tensor("float32", float32Data, dims);
          return inputTensor;
        }

    function sortedClasses(classProbabilities) {
      const probs = Array.from(classProbabilities);
      return probs.map((prob, i) => [prob, i])
        .sort((a, b) => b[0] - a[0])
        .map(([prob, index]) => ({
          index,
          name: modelClasses[index],
          probability: prob
        }));
    }

    function softmax(arr) {
      const max = Math.max(...arr);
      const exps = arr.map(x => Math.exp(x - max));
      const sum = exps.reduce((a, b) => a + b);
      return exps.map(e => e / sum);
    }

    // The inference function now reuses the loaded session for speed
    async function inference(path) {
      const imageTensor = await getImageTensorFromPath(path);
      statusOutput.textContent = statusDict[2]; // "Performing inference"
      const results = await inferenceSession.run({ input: imageTensor });
      return softmax(Array.from(results.output.data));
    }

    async function inputChanged(event) {
      // --- CHANGE 2: Cancel any previous timer that was set ---
      // This prevents the old results from clearing if a new image is uploaded quickly.
      if (clearResultsTimer) {
        clearTimeout(clearResultsTimer);
      }

      // First, check if the model is loaded and ready
      if (!inferenceSession) {
        statusOutput.textContent = "Model is not ready yet. Please wait.";
        return;
      }
      
      statusOutput.textContent = statusDict[1]; // "Loading file"
      const result = await inference(URL.createObjectURL(event.target.files[0]));
      const classes = sortedClasses(result);
      const outputDiv = document.getElementById("model-output");

      // Display the new results
      outputDiv.innerHTML = "";
      outputDiv.classList.remove("placeholder-text");
      classes.forEach((entry, index) => {
        const resultEl = document.createElement("div");
        resultEl.className = index === 0 ? "result top" : "result";
        resultEl.innerHTML = `
          <strong>${entry.name}</strong>
          <ul>
            <li>Class ID: ${entry.index}</li>
            <li>Probability: ${entry.probability.toFixed(4)}</li>
          </ul>`;
        outputDiv.appendChild(resultEl);
      });

      // Update status to "Inference complete"
      statusOutput.textContent = statusDict[3];

      // --- CHANGE 3: Start the 30-second timer AFTER inference is complete ---
      clearResultsTimer = setTimeout(() => {
        // This code will run after 30,000 milliseconds
        outputDiv.innerHTML = "Predictions will appear here...";
        outputDiv.classList.add("placeholder-text");
        // Reset the status to show the app is ready for another file
        statusOutput.textContent = statusDict[4]; 
      }, 30000); // 30 seconds
    }
  </script>
  
</body>
</html>



